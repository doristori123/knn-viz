<!DOCTYPE html>
<html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.indigo-pink.min.css">
<script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
<style>
body {
  font: 11px sans-serif;

}
#main {
    display: flex;
    margin: 40px;
}
#controls {
    width: 20%;
    margin-right: 20px;
}
#plot {
    margin-right: 40px;
    margin-left: 40px;
    position: relative;
    width:40%;
}

#dart {
 width: 40%;
}

.axis path,
.axis line {
  fill: none;
  stroke: rgb(165, 165, 165);
  shape-rendering: crispEdges;
  fill-opacity: 0.8;
}

.tick {
    fill: rgb(165, 165, 165); 
    fill-opacity: 0.8;
}
.dot {
}

.train {
    stroke: white;
    stroke-width: 1;
    stroke-opacity: 0.8;
    fill-opacity: 0.9;
}

.test{
    stroke: black;
    stroke-width: 1;
    stroke-opacity: 0.8;
    fill-opacity: 0.9; 
}


</style>
<body>
    <div id="main">
        <div id="controls" style="width:200px;">
            <h2>Settings</h2>
            <p>Parameter k:</p><span class="kval"></span>
            <input id="kparameter" class="mdl-slider mdl-js-slider" type="range"
            min="1" max="200" value="25" tabindex="0">
        </div>
        <div id="plot"></div>
        <div id="dart"></div>
    </div>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="/kdTree.js"></script>


<script>

// HYPERPARAMETERS 
const DENSITY = 50; //logical width and height for grid
var domain = [-4,4]; //the actual coordinate boundaries that we will use

// Display parameters
const   width = 600; // width in pixel for whole plot
const   height = 600; // height in pixel for whole plot
const   dartBoardSize = 400; //dartboard size in px size*size
var padding = 20; // padding for axes
var NUM_SHADES = 30;

/*

    SETUP DOM AND D3 OBJECTS

*/


//get our canvas element set up
var canvas = d3.select('#plot')
    .append('canvas')
    .attr("width", DENSITY)
    .attr("height", DENSITY)
    .style("width", (width - 2*padding) + "px")
    .style("height", (height - 2*padding) + "px")
    .style("position", "absolute")
    .style("top", `${padding}px`)
    .style("left", `${padding}px`);

//set up our svg (plot)
var svg = d3.select('#plot').append('svg')
    .attr("width", width)
    .attr("height", height)
    .style("position", "absolute")
    .style("left", "0")
    .style("top", "0")
    .append("g")
    .attr("transform", "translate(" + padding + "," + padding + ")");


// Set up our scales
var xScale = d3.scale.linear()
    .domain(domain)
    .range([0, width - 2 * padding]);

var yScale = d3.scale.linear()
    .domain(domain)
    .range([height - 2 * padding, 0]);

/*
    SETUP AXES
*/ 
var yAxis = d3.svg.axis()
    .scale(yScale)
    .orient("left");


var xAxis = d3.svg.axis()
    .scale(xScale)
    .orient("bottom");

// x-axis
svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + (height-2*padding) + ")")
    .call(xAxis)



// y-axis
svg.append("g")
    .attr("class", "y axis")
    .attr("transform", "translate(0,0)")
    .call(yAxis)



/*

        DARTBOARD SETUP

*/

var svgDartBoard = d3.select("#dart").append("svg")
                                    .attr("width", dartBoardSize)
                                    .attr("height", dartBoardSize)
                                    .append("g")



// Set up our scales
var dartScale = d3.scale.linear()
    .domain(domain)
    .range([0, dartBoardSize]);

var dartRadiusScale = d3.scale.linear()
    .domain([0,2])
    .range([0, dartBoardSize/2]); 


/**
 * 
 * Samples from a normal distribution. Uses the seedrandom library as the
 * random generator.
 *
 * @param mean The mean. Default is 0.
 * @param variance The variance. Default is 1.
 */
 function normalRandom(mean = 0, variance = 1) {

  do {
    var v1 = 2 * Math.random() - 1;
    var v2 = 2 * Math.random() - 1;
    var s = v1 * v1 + v2 * v2;
  } while (s > 1);

  var result = Math.sqrt(-2 * Math.log(s) / s) * v1;
  return mean + Math.sqrt(variance) * result;
}

function generateTrainingData(sampleSize, noise) {
    
    var points = []
    var variance = noise;

    function generateGaussian(cx, cy, label) {
        for (let i = 0; i < sampleSize / 2; i++) {
            
            let x = normalRandom(cx, variance);
            let y = normalRandom(cy, variance);
            points.push({x, y, label});
        
        }
    }

    generateGaussian(1,1,1)
    generateGaussian(-1,-1,-1)


    return points
}

function constructKDTree(points) {
    
    //Euclidean distance betweeen two points without the square root for optimization
    //since we only need relative distances 
    var distance = function(a, b){
        return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
    }
    
    var tree = new kdTree(points, distance, ["x", "y"]);
    return tree;
}


function getDecisionBoundary(tree, kval) {


    var densityToCoordinateX = d3.scale.linear().domain([0, DENSITY-1]).range(domain);
    var densityToCoordinateY = d3.scale.linear().domain([DENSITY-1,0]).range(domain);
    
    //define a grid with the given density 
    var grid = new Array(DENSITY);
    for(k = 0; k < DENSITY; k++)
    {
        grid[k] = new Array(DENSITY);
    }

    for(i = 0; i < DENSITY; i++)
    {
        for(j = 0; j < DENSITY; j++) {
            
            var nearest = tree.nearest({ x: densityToCoordinateX(i), y: densityToCoordinateY(j) }, kval);
            
            var sum = 0;
            var votes = []
            for (var h = 0; h < nearest.length; h++)
            {   
                votes.push(nearest[h][0].label)
                sum = sum + (nearest[h][0].label == -1 ? -1 : 1);
                
            }
            
            
            grid[i][j] = sum/kval
            
        }
    }
    return grid

}

// define color range
var tmpScale = d3.scale.linear()
        .domain([0, .5, 1])
        .range(["#f59322", "#e8eaeb", "#0877bd"])
        .clamp(true);
    
// Due to numerical error, we need to specify
// d3.range(0, end + small_epsilon, step)
// in order to guarantee that we will have end/step entries with
// the last element being equal to end.
var colors = d3.range(0, 1 + 1E-9, 1 / NUM_SHADES).map(a => {
    return tmpScale(a);
});

var color = d3.scale.quantize()
                     .domain([-1, 1])
                     .range(colors);


function labelToColor(label) {

    if (label == -1) // orange
        return d3.rgb(255, 127, 14)

    if (label == 1) // blue
        return d3.rgb(31, 119, 180)

}

function updateHeatmap(grid){


    var context = canvas.node().getContext('2d');
    var image = context.createImageData(DENSITY, DENSITY);


    for(j = 0, k = -1; j < DENSITY; ++j)
    {
        for(i = 0; i < DENSITY; ++i)
        {   
            c = d3.rgb(color(grid[i][j]));
            image.data[++k] = c.r;
            image.data[++k] = c.g;
            image.data[++k] = c.b;
            image.data[++k] = 190;
        }
    }
   
    context.putImageData(image, 0, 0);


}

var renderTrainingPoints = function(data) {
  // draw dot
  svg.selectAll(".dot")
      .data(data)
    .enter().append("circle")
      .attr("class", "dot")
      .attr("class", "train")
      .attr("r", 4.5)
      .attr("cx", xMap)
      .attr("cy", yMap)
      .style("fill", function(d) { return labelToColor(d.label);}) 
};

var renderTestPoints = function(data) {
    console.log(data)
  
  // draw dot
  svg.selectAll(".dot")
      .data(data)
    .enter().append("circle")
      .attr("class", "dot")
      .attr("class", "test")
      .attr("r", 4.5)
      .attr("cx", xMap)
      .attr("cy", yMap)
      .style("fill", function(d) { return labelToColor(d.label);}) 
};



var gaussianData = generateTrainingData(400,2);
//var testData = generateTrainingData(200,2);

// filter out points that fall out of our domain
gaussianData = gaussianData.filter(p => {
      return p.x >= domain[0] && p.x <= domain[1]
        && p.y >= domain[0] && p.y <= domain[1];
    });




var tree = constructKDTree(gaussianData);
var grid = getDecisionBoundary(tree,5);
updateHeatmap(grid);


// setup x 
var xValue = function(d) { return d.x;} // data -> value
var xMap = function(d) { return xScale(xValue(d));} // data -> display


// setup y
var yValue = function(d) { return d.y;} // data -> value
var yMap = function(d) { return yScale(yValue(d));} // data -> display

renderTrainingPoints(gaussianData);
//renderTestPoints(testData);
d3.select('#kparameter').on('change', function() {
  
  d3.select('.kval').text(this.value)
  grid = getDecisionBoundary(tree, this.value)
  updateHeatmap(grid)


});


var jsonCircles = [
   { "x_axis": 0, "y_axis": 0, "radius": 1.1, "color" : "white"},
   { "x_axis": 0, "y_axis": 0, "radius": 0.8, "color" : "#72B4DC"},
   { "x_axis": 0, "y_axis": 0, "radius": 0.5, "color" : "white" },
   { "x_axis": 0, "y_axis": 0, "radius": 0.2, "color" : "#C32D3B"},];

svgDartBoard.selectAll("circle")
    .data(jsonCircles)
    .enter()
    .append("circle")
    .attr("cx", function (d) { return dartScale(d.x_axis); })
        .attr("cy", function (d) { return dartScale(d.y_axis); })
        .attr("r", function (d) { return dartRadiusScale(d.radius); })
        .attr("stroke", "black")
        .attr("stroke-width", 3)
        .style("fill", function(d) { return d.color; });

</script>
</body>
</html>
