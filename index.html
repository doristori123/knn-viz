<!DOCTYPE html>
<html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.blue_grey-blue.min.css" />
<script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.17.0/math.min.js"></script>
<style>
body {
  
    background-color: #f7f7f7;
    
}

header {
    font-family: "Roboto","Helvetica","Arial",sans-serif;
    border-bottom: solid 1px rgba(0,0,0,0.4);
    background-color: #183D4E;
    overflow: hidden;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    position: relative;
    line-height: 1.45em;
    font-weight: 300;
    letter-spacing: -.02em;
    color: rgba(255, 255, 255, 0.7);

}

.heading {
    margin-left: auto;
    margin-right: auto;
    font-size: 30px;
    text-align: center;
    margin-top: 30px;
    margin-bottom: 30px;
    -webkit-font-smoothing: antialiased;
}

h1 {
    font-weight: 300;
}

.heading b{
    font-weight: 400;
    color: rgba(255, 255, 255, 1);
}

#main {
    display: flex;
    margin-left: auto;
    margin-right: auto;
    width: 1100px;
    margin-top: 30px;
    -webkit-justify-content: space-between;
    justify-content: space-between;
}

#main h4 {
    font-weight: 400;
    font-size: 20px;
    text-transform: uppercase;
}

#main span {
    font-weight: 300;
    font-size: 20px;
    margin-bottom: 10px;
    margin-right: 5px;
}

#colormap {
    vertical-align: top;
    margin-left: 20px;
}

#main p {
    color: #777;
    font-size: 16px;
    font-weight: 300;
    font-family: "Helvetica", "Arial", sans-serif;
}

.noisecontainer {
    margin-top: 20px;
}
.kselect > span {
    display: inline-block;
   
}

.error > p {
    display: inline-block;
    margin-right:10px;
   
}
#legend {
    margin-left: 40px;
}
#legend p {
    display:inline-block;
    font-size: 12px;
    line-height: 12px;
    width: 150px;
    
}
#controls {
    width: 20%;
}
#output {
    width:40%;
    
}

#plot{
    position: relative;
    width: 500px;
}

#plotcontainer {
    height: 430px;
}

#dartcontainer {
 width: 350px;

}

#dartcontainer {
    font-size: 14px;
}

#dartcontainer br {
    display: block;
    margin: 10px 0;}

.axis path,
.axis line {
  fill: none;
  stroke: rgb(165, 165, 165);
  shape-rendering: crispEdges;
  fill-opacity: 0.8;
}

.tick {
    fill: rgb(165, 165, 165); 
    fill-opacity: 0.8;
}
.dot {
}

.train {
    stroke: white;
    stroke-width: 1;
    stroke-opacity: 0.8;
    fill-opacity: 0.9;
}

.test{
    stroke: black;
    stroke-width: 1;
    stroke-opacity: 0.8;
    fill-opacity: 0.9; 
}

#test {
    margin-top: 20px;
}
#test p {
    display: inline-block;
}


/* Slider */

#main-part .mdl-slider.is-upgraded {
  color: #183D4E;
}

#main-part .mdl-slider__background-lower {
  background-color: #183D4E;
}

#main-part .mdl-slider.is-upgraded::-webkit-slider-thumb {
  background-color: #183D4E;
}

#main-part .mdl-slider.is-upgraded::-moz-range-thumb {
  background-color: #183D4E;
}

#main-part .mdl-slider.is-upgraded::-ms-thumb {
  background-color: #183D4E;
}

#main-part .mdl-slider.is-upgraded.is-lowest-value::-webkit-slider-thumb {
  border-color: #183D4E;
}

#main-part .mdl-slider.is-upgraded.is-lowest-value::-moz-range-thumb {
  border-color: #183D4E;
}
/* Keep grey focus circle for non-start values */
#main-part .mdl-slider.is-upgraded:focus:not(:active)::-webkit-slider-thumb {
  box-shadow: 0 0 0 10px rgba(0,0,0, 0.12);
}


</style>
<body>
    <header>
            <h1 class="heading">Tinker With K-nearest Neighbours to Better Understand the <b>Bias-Variance Tradeoff</b> </h1>
    </header>
    <div id="main">
        <div id="controls" style="width:200px;">
            <h4>Settings</h4>
            <p>Choose the number of nearest neighbours:</p><div class="kselect"><span>K:</span><span class="kval"></span></div>
            <input id="kparameter" class="mdl-slider mdl-js-slider" type="range"
            min="0" max="20" value="10" tabindex="0">
            
            <div class="noisecontainer">
                <p>Noise level:</p><span class="noiseval"></span>
                <input id="noiseparameter" class="mdl-slider mdl-js-slider" type="range"
                min="10" max="100" step="10" value="50" tabindex="0">
            </div>

            <div id="test">
                    <input type="checkbox" name="testing" id="testdatacheckbox">
                    <p><label for="testing">Show test data</label></p>
            </div>

            <h4>Metrics</h4>
            <div class="error">
                <p>Training error: </p><span id="training_error"></span>

                <p>Test error: </p><span id="test_error"></span>
            </div>
            

        </div>
        <div id="output">
                <h4>Output</h4>
                <div id="plotcontainer">
                    <div id="plot"></div>
                </div>

                <div id="legend">
                    <p>
                        Color shows the confidence of our prediction where 0 means unsure <br>
                         <br>
                        
                    </p>
                    <svg width="150" height="30" id="colormap">
                            <defs>
                                <linearGradient id="gradient" x1="0%" y1="100%" x2="100%" y2="100%">
                                <stop offset="0%" stop-color="#f59322" stop-opacity="1"></stop>
                                <stop offset="50%" stop-color="#e8eaeb" stop-opacity="1"></stop>
                                <stop offset="100%" stop-color="#0877bd" stop-opacity="1"></stop>
                                </linearGradient>
                            </defs>
                    
                            <g class="core" transform="translate(3, 0)">
                                <rect width="144" height="10" style="fill: url('#gradient');"></rect>
                            </g>
                    </svg>
                </div>
                
                
                
                
        </div>
        <div id="dartcontainer">
                <h4>Bias and Variance</h4>
                <div id="dart"></div>
                <p> - Each point represents your model fit on a new set of training data<p>
                <p> - The closer the points are to the center the more accurately they model the true distribution </p>
                <p> - A higher dispersion suggests your model is overfitting to the variance in the underlying data distribution </p>
            </div>
    </div>

<script src="https://fastcdn.org/D3.js/3.5.6/d3.min.js"></script>
<script src="kdTree.js"></script>
<script src="multivariate-normal.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js"></script>



<script>

// HYPERPARAMETERS 
const DENSITY = 50; //logical width and height for grid
var domain = [-3.5,3.5]; //the actual coordinate boundaries that we will use

// Display parameters
const width = 400; // width in pixel for whole plot
const height = 400; // height in pixel for whole plot
const dartBoardSize = 250; //dartboard size in px size*size
var kval = 5;
const padding = 20; // padding for axes
const NUM_SHADES = 30;
const K_VALS = [1,2,3,4,5,6,7,9,10,11,12,20,30,40,60,80,100,120,140,160];
var noise = 50;
var MultivariateNormal = window.MultivariateNormal.default;
/*

    SETUP DOM AND D3 OBJECTS

*/


//get our canvas element set up
var canvas = d3.select('#plot')
    .append('canvas')
    .attr("width", DENSITY)
    .attr("height", DENSITY)
    .style("width", (width - 2*padding) + "px")
    .style("height", (height - 2*padding) + "px")
    .style("position", "absolute")
    .style("top", `${padding}px`)
    .style("left", `${padding}px`);

//set up our svg (plot)
var svg = d3.select('#plot').append('svg')
    .attr("width", width)
    .attr("height", height)
    .style("position", "absolute")
    .style("left", "0")
    .style("top", "0")
    .append("g")
    .attr("transform", "translate(" + padding + "," + padding + ")");

//Setup colormap
// Add scale to the gradient color map.
var xColor = d3.scale.linear().domain([-1, 1]).range([0, 144]);
var xColorAxis = d3.svg.axis()
    .scale(xColor)
    .orient("bottom")
    .tickValues([-1, 0, 1])
    .tickFormat(d3.format("d"));

d3.select("#colormap g.core").append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0,10)")
    .call(xColorAxis);

// Set up our scales
var xScale = d3.scale.linear()
    .domain(domain)
    .range([0, width - 2 * padding]);

var yScale = d3.scale.linear()
    .domain(domain)
    .range([height - 2 * padding, 0]);

/*
    SETUP AXES
*/ 
var yAxis = d3.svg.axis()
    .scale(yScale)
    .orient("left");


var xAxis = d3.svg.axis()
    .scale(xScale)
    .orient("bottom");

// x-axis
svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + (height-2*padding) + ")")
    .call(xAxis)



// y-axis
svg.append("g")
    .attr("class", "y axis")
    .attr("transform", "translate(0,0)")
    .call(yAxis)



/*

        DARTBOARD SETUP

*/

var svgDartBoard = d3.select("#dart").append("svg")
                                    .attr("width", dartBoardSize)
                                    .attr("height", dartBoardSize)
                                    .append("g")



// Set up our scales
var dartScale = d3.scale.linear()
    .domain(domain)
    .range([0, dartBoardSize]);

var dartRadiusScale = d3.scale.linear()
    .domain([0,2])
    .range([0, dartBoardSize/2]); 



var noiseMap = d3.scale.linear().domain([10,100]).range([0.05,0.2])
var biasMap = d3.scale.linear().domain([0,0.3]).range([0,3])

/**
 * 
 * Samples from a normal distribution. Uses the seedrandom library as the
 * random generator.
 *
 * @param mean The mean. Default is 0.
 * @param variance The variance. Default is 1.
 */
 function normalRandom(mean = 0, variance = 1) {

  do {
    var v1 = 2 * Math.random() - 1;
    var v2 = 2 * Math.random() - 1;
    var s = v1 * v1 + v2 * v2;
  } while (s > 1);

  var result = Math.sqrt(-2 * Math.log(s) / s) * v1;
  return mean + Math.sqrt(variance) * result;
}

function generateTrainingData(sampleSize, noise) {
    
    var points = []
    var variance = noise;

    function generateGaussian(cx, cy, label) {
        for (var i = 0; i < sampleSize / 2; i++) {
            
            var x = normalRandom(cx, variance);
            var y = normalRandom(cy, variance);
            points.push({x, y, label});
        
        }
    }

    generateGaussian(1,1,1)
    generateGaussian(-1,-1,-1)


    return points
}

function get_means() {
    var identidy_mat = [
        [ 2.0, 0.0,],
        [ 0.0, 2.0]
    ];

    var mean_sample_size = 10;

    var mean_distribution_class1 = MultivariateNormal([0.5,-0.5], identidy_mat)
    var mean_distribution_class2 = MultivariateNormal([-0.5,0.5], identidy_mat)

    var means_class_1 = [];
    var means_class_2 = [];
    
    for(var i = 0; i < mean_sample_size; i++)
    {   
        var mean_1 = mean_distribution_class1.sample()
        means_class_1.push({
            'x': mean_1[0],
            'y': mean_1[1],
            'label': 1
        });

        var mean_2 = mean_distribution_class2.sample();
        means_class_2.push({
            'x': mean_2[0],
            'y': mean_2[1],
            'label': -1
        });
    }

    return [means_class_1, means_class_2]
}

//As described in ESL
function new_generateData(sampleSize, noise, means)
{
    var means_class_1 = means[0]
    var means_class_2 = means[1]

    var data = []
    var identidy_mat_small = [
        [noise, 0.0,],
        [ 0.0, noise]
    ];
    for(var i = 0; i < sampleSize/2; i++)
    {
        var mean_class_1 = means_class_1[Math.floor(Math.random()*means_class_1.length)];
        var distribution_class_1 = MultivariateNormal([mean_class_1.x, mean_class_1.y], identidy_mat_small)
        var sample_point = distribution_class_1.sample()
        data.push({
            'x': sample_point[0],
            'y': sample_point[1],
            'label': 1
        })

        var mean_class_2 = means_class_2[Math.floor(Math.random()*means_class_2.length)];
        var distribution_class_2 = MultivariateNormal([mean_class_2.x, mean_class_2.y], identidy_mat_small)
        sample_point = distribution_class_2.sample()
        data.push({
            'x': sample_point[0],
            'y': sample_point[1],
            'label': -1
        })

    }

    return data



}

function constructKDTree(points) {
    
    //Euclidean distance betweeen two points without the square root for optimization
    //since we only need relative distances 
    var distance = function(a, b){
        return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
    }
    
    var tree = new kdTree(points, distance, ["x", "y"]);
    return tree;
}


function getDecisionBoundary(tree, kval) {


    var densityToCoordinateX = d3.scale.linear().domain([0, DENSITY-1]).range(domain);
    var densityToCoordinateY = d3.scale.linear().domain([DENSITY-1,0]).range(domain);
    
    //define a grid with the given density 
    var grid = new Array(DENSITY);
    for(k = 0; k < DENSITY; k++)
    {
        grid[k] = new Array(DENSITY);
    }

    for(i = 0; i < DENSITY; i++)
    {
        for(j = 0; j < DENSITY; j++) {
            
            var nearest = tree.nearest({ x: densityToCoordinateX(i), y: densityToCoordinateY(j) }, kval);
            
            var sum = 0;
            var votes = []
            for (var h = 0; h < nearest.length; h++)
            {   
                votes.push(nearest[h][0].label)
                sum = sum + (nearest[h][0].label == -1 ? -1 : 1);
                
            }
            
            
            grid[i][j] = sum/kval
            
        }
    }
    return grid

}

// define color range
var tmpScale = d3.scale.linear()
        .domain([0, .5, 1])
        .range(["#f59322", "#e8eaeb", "#0877bd"])
        .clamp(true);
    
// Due to numerical error, we need to specify
// d3.range(0, end + small_epsilon, step)
// in order to guarantee that we will have end/step entries with
// the last element being equal to end.
var colors = d3.range(0, 1 + 1E-9, 1 / NUM_SHADES).map(a => {
    return tmpScale(a);
});

var color = d3.scale.quantize()
                     .domain([-1, 1])
                     .range(colors);


function labelToColor(label) {

    if (label == -1) // orange
        return d3.rgb(255, 127, 14)

    if (label == 1) // blue
        return d3.rgb(31, 119, 180)

}

function updateHeatmap(grid){


    var context = canvas.node().getContext('2d');
    var image = context.createImageData(DENSITY, DENSITY);


    for(j = 0, k = -1; j < DENSITY; ++j)
    {
        for(i = 0; i < DENSITY; ++i)
        {   
            c = d3.rgb(color(grid[i][j]));
            image.data[++k] = c.r;
            image.data[++k] = c.g;
            image.data[++k] = c.b;
            image.data[++k] = 190;
        }
    }
   
    context.putImageData(image, 0, 0);


}

var renderTrainingPoints = function(data) {
 
    svg.selectAll("circle").remove();
    // draw dot
  svg.selectAll(".dot")
      .data(data)
    .enter().append("circle")
      .attr("class", "dot")
      .attr("class", "train")
      .attr("r", 4.5)
      .attr("cx", xMap)
      .attr("cy", yMap)
      .style("fill", function(d) { return color(d.label);}) 
};

var renderTestPoints = function(data) {
    
  
  // draw dot
  svg.selectAll(".dot")
      .data(data)
    .enter().append("circle")
      .attr("class", "dot")
      .attr("class", "test")
      .attr("r", 4.5)
      .attr("cx", xMap)
      .attr("cy", yMap)
      .style("fill", function(d) { return labelToColor(d.label);}) 
};


var means = get_means();
console.log(means);

var gaussianData = new_generateData(400,noiseMap(noise), means);
//var testData = generateTrainingData(200,2);

// filter out points that fall out of our domain
gaussianData = gaussianData.filter(p => {
      return p.x >= domain[0] && p.x <= domain[1]
        && p.y >= domain[0] && p.y <= domain[1];
    });

var testData = new_generateData(400, noiseMap(noise), means);
testData = testData.filter(p => {
      return p.x >= domain[0] && p.x <= domain[1]
        && p.y >= domain[0] && p.y <= domain[1];
    });

var tree = constructKDTree(gaussianData);
var grid = getDecisionBoundary(tree,kval);
updateHeatmap(grid);


// setup x 
var xValue = function(d) { return d.x;} // data -> value
var xMap = function(d) { return xScale(xValue(d));} // data -> display


// setup y
var yValue = function(d) { return d.y;} // data -> value
var yMap = function(d) { return yScale(yValue(d));} // data -> display

//Set k label
d3.select('.kval').text(kval)
d3.select('.noiseval').text(noise)


calculate_error = function(tree,dat, kval) {
    
    var error = 0;
    for(var i = 0; i<dat.length; i++)
    {
        var nearest = tree.nearest({ x: dat[i].x, y: dat[i].y }, kval);
            
            var sum = 0;
            var votes = []
            for (var h = 0; h < nearest.length; h++)
            {   
                votes.push(nearest[h][0].label)
                sum = sum + (nearest[h][0].label == -1 ? -1 : 1);
                
            }

            var predicted_label = sum > 0 ? 1 : -1;
            //console.log("Predicted/True label: {0}, {1} ".format(predicted_label, dat[i].label))
            var error = error + (predicted_label == dat[i].label ? 0 : 1);
            
            // console.log(error)
    }

    return error/dat.length;
}

renderTrainingPoints(gaussianData);
var training_error = calculate_error(tree, gaussianData, kval);
d3.select('#training_error').text(training_error.toFixed(2));

var test_error = calculate_error(tree, testData, kval);
d3.select('#test_error').text(test_error.toFixed(2));



// UTIL
// FROM https://stackoverflow.com/questions/25227119/javascript-strings-format-is-not-defined
String.prototype.format = function () {
        var args = [].slice.call(arguments);
        return this.replace(/(\{\d+\})/g, function (a){
            return args[+(a.substr(1,a.length-2))||0];
        });
};


var calculate_bias_variance = function(k) {


    var num_sampledatasets = 10
    var err_arr = [];
    for (var i = 0; i < num_sampledatasets; i++) 
    {   
        var dat = new_generateData(1000,2, means);
        var err = calculate_error(tree, dat, k);
        err_arr.push(err)
    }

    console.log(k)
    console.log(err_arr);
    console.log("Mean:", math.mean(err_arr))
    console.log("Standard deviation:", math.pow(math.std(err_arr),2))
}

var getDartBoardPoints = function(bias, variance) {

    var theta = Math.floor(Math.random() * (360 - 0 + 1)) + 0;
    var xCoord = bias*math.cos(math.unit(theta, 'deg'));
    var yCoord = bias*math.sin(math.unit(theta, 'deg'));
    var points = []
    var n = 20;

    var identidy_mat = [
        [ variance, 0.0,],
        [ 0.0, variance]
    ];

    var distribution = MultivariateNormal([xCoord, yCoord], identidy_mat)
    
    for(var j = 0; j < 10; j++) {
        var point = distribution.sample();
        points.push({
                'x': point[0],
                'y': point[1]
            });
        }

    return points

}

var renderDartBoard = function(points) {

    //Clear old points
    svgDartBoard.selectAll(".train").remove();

    //Draw new ones
    svgDartBoard.selectAll(".dot")
        .data(points)
        .enter().append("circle")
      .attr("class", "dot")
      .attr("class", "train")
      .attr("r", 3.5)
      .attr("cx", function (d) { return dartScale(d.x); })
      .attr("cy", function (d) { return dartScale(d.y); })
      .style("fill", "blue") 
}



//calculate_bias_variance(init_k);

var getVarianceOfModel = function(noise, k)
{

    return noise/k;
}


var getBiasOfModel = function(means, k)
{
    var num_training_sets = 100;

    var errors = []
    var meanvector = means[0].concat(means[1])
    for(var i = 0; i < num_training_sets; i++)
    {
        var data = new_generateData(400,noiseMap(noise), means);
    
        // filter out points that fall out of our domain
        data = data.filter(p => {
            return p.x >= domain[0] && p.x <= domain[1]
                && p.y >= domain[0] && p.y <= domain[1];
            });
        
       var tree = constructKDTree(data);

       
       var error = calculate_error(tree, meanvector, kval);
       errors.push(error)
        
   
   
    }

    return errors
    

}





//renderTestPoints(testData);
d3.select('#kparameter').on('change', function() {
  
    console.log("NEW K", this.value)
  kval = K_VALS[this.value];
  d3.select('.kval').text(kval)
  grid = getDecisionBoundary(tree, kval)
  updateHeatmap(grid)
 // calculate_bias_variance(this.value);
  var biasvec = getBiasOfModel(means, kval)
  var dartPoints = getDartBoardPoints(biasMap(math.mean(biasvec)), getVarianceOfModel(noiseMap(noise)*5,kval));
  renderDartBoard(dartPoints);
  var training_error = calculate_error(tree, gaussianData, kval);
  d3.select('#training_error').text(training_error.toFixed(2));

  var test_error = calculate_error(tree, testData, kval);
  d3.select('#test_error').text(test_error.toFixed(2));
  console.log(biasvec)
  console.log(math.mean(biasvec))

});

d3.select('#noiseparameter').on('change', function() {
    
    noise = this.value;
    d3.select('.noiseval').text(this.value)  
    gaussianData = new_generateData(400,noiseMap(this.value), means);
    
    // filter out points that fall out of our domain
    gaussianData = gaussianData.filter(p => {
        return p.x >= domain[0] && p.x <= domain[1]
            && p.y >= domain[0] && p.y <= domain[1];
        });

    renderTrainingPoints(gaussianData);

    var tree = constructKDTree(gaussianData);

    grid = getDecisionBoundary(tree, kval)
    updateHeatmap(grid)
    var biasvec = getBiasOfModel(means, kval)
    var dartPoints = getDartBoardPoints(biasMap(math.mean(biasvec)), getVarianceOfModel(noiseMap(this.value)*5,kval));
    renderDartBoard(dartPoints);

    var training_error = calculate_error(tree, gaussianData, kval);
    d3.select('#training_error').text(training_error.toFixed(2));
  
    var test_error = calculate_error(tree, testData, kval);
    d3.select('#test_error').text(test_error.toFixed(2));
  
    console.log(biasvec)
    console.log(math.mean(biasvec))


});

d3.select('#testdatacheckbox').on('change', function() {
    
    if(this.checked)
    {
        renderTestPoints(testData);
    }

    else{
        svg.selectAll(".test").remove();
    }

});






var jsonCircles = [
   { "x_axis": 0, "y_axis": 0, "radius": 1.1*1.5, "color" : "white"},
   { "x_axis": 0, "y_axis": 0, "radius": 0.8*1.5, "color" : "#72B4DC"},
   { "x_axis": 0, "y_axis": 0, "radius": 0.5*1.5, "color" : "white" },
   { "x_axis": 0, "y_axis": 0, "radius": 0.2*1.5, "color" : "#C32D3B"},];

svgDartBoard.selectAll("circle")
    .data(jsonCircles)
    .enter()
    .append("circle")
    .attr("cx", function (d) { return dartScale(d.x_axis); })
        .attr("cy", function (d) { return dartScale(d.y_axis); })
        .attr("r", function (d) { return dartRadiusScale(d.radius); })
        .attr("stroke", "black")
        .attr("stroke-width", 3)
        .style("fill", function(d) { return d.color; });

  var biasvec = getBiasOfModel(means, kval)
  var dartPoints = getDartBoardPoints(biasMap(math.mean(biasvec)), getVarianceOfModel(noiseMap(noise)*5,kval));
  renderDartBoard(dartPoints);
  

$("#button").click(function() {
    $('html, body').animate({
        scrollTop: $("#myDiv").offset().top
    }, 2000);
});
 

</script>
</body>
</html>
