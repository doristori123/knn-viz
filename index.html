<!DOCTYPE html>
<html>
<meta charset="utf-8">

<style>
body {
  font: 11px sans-serif;
}

#plot {
    margin: 40px;
    position: relative;
}

.axis path,
.axis line {
  fill: none;
  stroke: rgb(165, 165, 165);
  shape-rendering: crispEdges;
  fill-opacity: 0.8;
}

.tick {
    fill: rgb(165, 165, 165); 
    fill-opacity: 0.8;
}
.dot {
      stroke: white;
    stroke-width: 1;
    stroke-opacity: 0.8;
    fill-opacity: 0.9;
}


</style>
<body>

<div id="plot"></div>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="/kdTree.js"></script>

<script>

// HYPERPARAMETERS 
const DENSITY = 10; //logical width and height for grid
var domain = [-4,4]; //the actual coordinate boundaries that we will use

// Display parameters
const   width = 400; // width in pixel for whole plot
const   height = 400; // height in pixel for whole plot
var padding = 20; // padding for axes


/*

    SETUP DOM AND D3 OBJECTS

*/

 //get our canvas element set up
 var canvas = d3.select('#plot')
        .append('canvas')
        .attr("width", DENSITY)
        .attr("height", DENSITY)
        .style("width", (width - 2*padding) + "px")
        .style("height", (height - 2*padding) + "px")
        .style("position", "absolute")
        .style("top", `${padding}px`)
        .style("left", `${padding}px`);

//set up our svg (plot)
var svg = d3.select('#plot').append('svg')
    .attr("width", width)
    .attr("height", height)
    .style("position", "absolute")
    .style("left", "0")
    .style("top", "0")
    .append("g")
    .attr("transform", "translate(" + padding + "," + padding + ")");


// Set up our scales
var xScale = d3.scale.linear()
    .domain(domain)
    .range([0, width - 2 * padding]);

var yScale = d3.scale.linear()
    .domain(domain)
    .range([height - 2 * padding, 0]);

/*
    SETUP AXES
*/ 
var yAxis = d3.svg.axis()
    .scale(yScale)
    .orient("left");


var xAxis = d3.svg.axis()
    .scale(xScale)
    .orient("bottom");

// x-axis
svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + (height-2*padding) + ")")
    .call(xAxis)



// y-axis
svg.append("g")
    .attr("class", "y axis")
    .attr("transform", "translate(0,0)")
    .call(yAxis)




/**
 * 
 * Samples from a normal distribution. Uses the seedrandom library as the
 * random generator.
 *
 * @param mean The mean. Default is 0.
 * @param variance The variance. Default is 1.
 */
 function normalRandom(mean = 0, variance = 1) {

  do {
    var v1 = 2 * Math.random() - 1;
    var v2 = 2 * Math.random() - 1;
    var s = v1 * v1 + v2 * v2;
  } while (s > 1);

  var result = Math.sqrt(-2 * Math.log(s) / s) * v1;
  return mean + Math.sqrt(variance) * result;
}

function generateTrainingData(sampleSize, noise) {
    
    var points = []
    var variance = noise;

    function generateGaussian(cx, cy, label) {
        for (let i = 0; i < sampleSize / 2; i++) {
            
            let x = normalRandom(cx, variance);
            let y = normalRandom(cy, variance);
            points.push({x, y, label});
        
        }
    }

    generateGaussian(2,2,1)
    generateGaussian(-2,-2,-1)

    return points
}

function constructKDTree(points) {
    
    //Euclidean distance betweeen two points without the square root for optimization
    //since we only need relative distances 
    var distance = function(a, b){
        return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
    }
    
    var tree = new kdTree(points, distance, ["x", "y"]);
    return tree;
}


function getDecisionBoundary(tree) {

    //define a grid with the given density 
    var grid = new Array(DENSITY);
    for(k = 0; k < DENSITY; k++)
    {
        grid[k] = new Array(DENSITY);
    }

    for(i = 0; i < DENSITY; i++)
    {
        for(j = 0; j < DENSITY; j++) {
            
            var nearest = tree.nearest({ x: i, y: j }, 5);
        
            var sum = 0;
            for (var h = 0; h < nearest.length; h++)
            {   
                sum = sum + (nearest[h][0].label == 0 ? -1 : 1);
            
            }

            grid[i][j] = (sum >= 0 ? 1 : 0)
            
        }
    }
    return grid

}

function labelToColor(label) {

    if (label == 0)
        return d3.rgb(255, 127, 14)

    if (label == 1)
        return d3.rgb(31, 119, 180)

}

function updateHeatmap(grid){


    var context = canvas.node().getContext('2d');
    var image = context.createImageData(DENSITY, DENSITY);


    for(i = 0, k = -1; i < DENSITY; ++i)
    {
        for(j = 0; j < DENSITY; ++j)
        {
            c = labelToColor(grid[i][j]);
            
            image.data[++k] = c.r;
            image.data[++k] = c.g;
            image.data[++k] = c.b;
            image.data[++k] = 140;
        }
    }
   
    context.putImageData(image, 0, 0);

    

}

var gaussianData = generateTrainingData(200,0.5);

// filter out points that fall out of our domain
gaussianData = gaussianData.filter(p => {
      return p.x >= domain[0] && p.x <= domain[1]
        && p.y >= domain[0] && p.y <= domain[1];
    });

var tree = constructKDTree(gaussianData);
console.log(gaussianData);
var grid = getDecisionBoundary(tree);
updateHeatmap(grid);


// setup x 
var xValue = function(d) { return d.x;}, // data -> value
    xMap = function(d) { return xScale(xValue(d));} // data -> display


// setup y
var yValue = function(d) { return d.y;}, // data -> value
    yMap = function(d) { return yScale(yValue(d));} // data -> display

// setup fill color
var cValue = function(d) { return d.label;},
    color = d3.scale.category10();

  // draw dot
  svg.selectAll(".dot")
      .data(gaussianData)
    .enter().append("circle")
      .attr("class", "dot")
      .attr("r", 3.5)
      .attr("cx", xMap)
      .attr("cy", yMap)
      .style("fill", function(d) { return color(cValue(d));}) 




</script>
</body>
</html>
